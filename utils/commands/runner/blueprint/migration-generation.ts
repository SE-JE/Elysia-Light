import { conversion, logger } from "@utils";
import fs from "fs";
import path from "path";

// ==================================>
// ## Command: Blueprint migration generation
// ==================================>
export async function migrationGeneration(
model      :  string,
schema     :  Record<string, string> = {},
relations  :  Record<string, string> = {},
marker     :  string
)          :  Promise<boolean> {
  const name       =  conversion.strSnake(conversion.strPlural(model.split("/").pop() || ""));
  const basePath   =  path.join(process.cwd(), "src","database", "migrations", "0000_00");
  const filename   =  `${name}.ts`;
  const filePath   =  path.join(basePath, filename);
  const className  =  `create${conversion.strPascal(name)}Table`

  const existingMigrations = fs.readdirSync(basePath).filter((f) => f.includes(`${name}`));

  for (const file of existingMigrations) {
    if (fs.existsSync(path.join(basePath, file))) {
      const content = fs.readFileSync(path.join(basePath, file), "utf-8")

      if (!content.includes("AUTO-GENERATED BY BLUEPRINT")) {
        logger.info(`Skip overridden file: ${name}.ts`)
        return false
      }
    }
  }

  const migrationFields: string[]  =  [];
  const pivots: string[]           =  []

  if (relations) {
    for (const target of extractBelongsTo(relations)) {
      const [fk, table, isFk] = getTargetRelation(target)
      
      if (schema[fk as string]) continue
      
      migrationFields.push(`table.foreignIdFor("${table}"${isFk ? `, "${fk}"` : ""})`)
    }

    for (const target of extractBelongsToMany(relations)) {
      const sourceTable = name
      const targetTable = conversion.strSnake(conversion.strPlural(target))

      if (sourceTable < targetTable) continue

      const pivotTable = getTargetTableRelation(sourceTable, targetTable)

      pivots.push(`  await knex.schema.createTable("${pivotTable}", (table) => {`)

      pivots.push(`    table.foreignIdFor("${sourceTable}")`)
      pivots.push(`    table.foreignIdFor("${targetTable}")`)

      pivots.push(`  })`)
    }
  }

  for (const [column, definition] of Object.entries(schema)) {
    const typeMatch = /type:(\w+),?(\d+)?/.exec(definition);
    const type = typeMatch?.[1] ?? "string";
    const length = typeMatch?.[2];

    let columnDef = "";
    switch (type) {
      case "bigInt":
      case "bigint":
      case "bigInteger":
        columnDef = `table.bigInteger("${column}").unsigned()`;
        break;
      case "int":
      case "integer":
        columnDef = `table.integer("${column}")`;
        break;
      case "string":
        columnDef = length
          ? `table.string("${column}", ${length})`
          : `table.string("${column}")`;
        break;
      case "text":
        columnDef = `table.text("${column}")`;
        break;
      case "foreignIdFor":
        columnDef = `table.foreignIdFor("${length}")`;
        break;
      default:
        columnDef = `table.${type}("${column}")`;
        break;
    }

    if (definition.includes("unique")) {
      columnDef += `.unique()`;
    }
    if (definition.includes("required")) {
      columnDef += `.notNullable()`;
    }
    if (definition.includes("index")) {
      columnDef += `.index()`;
    }

    migrationFields.push(columnDef);
  }

  const migrationSchema = migrationFields.map((f) => `    ${f}`).join("\n");

  const stubPath = path.join(process.cwd(), "src", "utils", "commands", "make", "stubs", "light-migration.stub");
  let stub = fs.readFileSync(stubPath, "utf-8");

  stub  =  stub
    .replace(/{{\s*marker\s*}}/g, marker)
    .replace(/{{\s*className\s*}}/g, className)
    .replace(/{{\s*tableName\s*}}/g, name)
    .replace(/{{\s*schemas\s*}}/g, migrationSchema)
    .replace(/{{\s*pivot\s*}}/g, pivots.join('\n'));

  if (!fs.existsSync(basePath)) {
    fs.mkdirSync(basePath, { recursive: true });
  }

  fs.writeFileSync(filePath, stub, "utf-8");

  return true;
}


function extractBelongsTo(relations: Record<string, string>) {
  return Object.values(relations)
    .filter(r => !r.includes("[]"))
    .map(r => r.replace(":", "").trim())
}

function getTargetRelation(model: string) {
  const base = model?.split(",")?.[0].split("/").pop()!
  const fk = model?.split(",")?.[1] || `${conversion.strSnake(base)}_id`

  return [fk, `${conversion.strPlural(conversion.strSnake(base))}`, !!model?.split(",")?.[1]]
}

function extractBelongsToMany(relations: Record<string, string>) {
  return Object.values(relations)
    .filter(r => r.startsWith("[]:"))
    .map(r => r.replace("[]:", "").trim())
}

function getTargetTableRelation(source: string, target: string) {
  const a = conversion.strSnake(
    conversion.strPlural(source.split("/").pop()!)
  )
  const b = conversion.strSnake(
    conversion.strPlural(target.split("/").pop()!)
  )
  return `${a}_has_${b}`
}