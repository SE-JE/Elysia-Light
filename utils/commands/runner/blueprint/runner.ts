import { conversion } from './../../../conversion.util';
import fs from "fs";
import path from "path";
import { Command } from "commander";
import { logger } from "@utils";
import { modelGeneration } from "./model-generation";
import { migrationGeneration } from "./migration-generation";
import { controllerGeneration } from "./controller-generation";
import { seederGeneration } from "./seeder-generation";
import { generateDrawioEntityDocumentation, generateMermaidEntityDocumentation, generatePostmanAPIDocumentation } from "./documentation-generation";
import { exec as execCb } from "child_process"
import { promisify } from "util"

const exec = promisify(execCb)


export interface BlueprintSchema {
  model         :  string;
  schema       ?:  Record<string, string>;
  relations    ?:  Record<string, string>;
  controllers  ?:  Record<string, string> | false;
  seeders      ?:  any[][];
}



const blueprintMarker = `// ============================================
// ## file THIS FILE IS AUTO-GENERATED BY BLUEPRINT
// ?? Blueprint : {{ blueprint }}
// !! If this comment is removed, blueprint engine WILL NOT override this file.
// ============================================


`



// =====================================>
// ## Command: blueprint
// =====================================>
export const blueprintCommand = new Command("blueprint")
  .option("-o, --only <names...>", "Run only specific blueprints")
  .description("Run blueprints")
  .action(async (opts) => {
    await runBlueprints({ only: opts.only })

    logger.info("Success run all blueprints!")
    
    await exec("bunx barrelsby -c barrels.json", { cwd: path.resolve() })

    logger.info("Success generate auto import all modules!")
    
    process.exit(0);
  })


// =======================>
// ## Command: Blueprint engine
// =======================>
export async function runBlueprints(options?: { only?: string[] }) {
  const loaded = loadBlueprintFiles()
  const postmanSchemas: any[] = []

  for (const file of loaded) {
    const name = file.file.replace(".blueprint.json", "")

    if (options?.only && !options.only.includes(name)) continue

    const marker = blueprintMarker.replace(/{{ blueprint }}/g, file.file)

    for (const struct of file.blueprints) {
      const schema      = struct.schema ?? {}
      const relations   = struct.relations ?? {}
      const seeders     = struct.seeders ?? []
      const controllers = struct.controllers ?? []

      await modelGeneration(struct.model, schema, relations, marker)

      if (struct.migrations !== false) {
        await migrationGeneration(struct.model, schema, relations, marker)
      }

      if (controllers !== false) {
        if (!!controllers.length) {
          controllers.map(async (item: string) => {
            const [controller, route, permission] = item.split(" ")
            await controllerGeneration(struct.model, schema, relations, controller, route || controller, permission, marker)
          })
        } else {
          const permission = Math.floor(Math.random() * 1000).toString().padStart(3, "0")
          await controllerGeneration(struct.model, schema, relations, struct.model, struct.model, permission, marker)
        }

        if(struct.postman !== false) {
          const controllerRoutes = Array.isArray(controllers) && controllers.length ? controllers.map(c => {
            const [controller, route] = c.split(" ")
            return route || controller
          }) : [struct.model]

          postmanSchemas.push({
            model: struct.model,
            schema,
            controllers: controllerRoutes
          })
        }
      }

      if (seeders.length) {
        await seederGeneration(struct.model, schema, seeders, marker)
      }

      if(struct.mermaid !== false) {
        await generateMermaidEntityDocumentation(file.file, file.blueprints)
      }
    }
  }

  await generateDrawioEntityDocumentation(loaded)
  await generatePostmanAPIDocumentation(postmanSchemas)
}


// =======================>
// ## Command: Blueprint load json files
// =======================>
function loadBlueprintFiles(dir = "blueprints") {
  const basePath = path.join(process.cwd(), "src", dir)

  if (!fs.existsSync(basePath)) {
    throw new Error("Blueprint folder not found")
  }

  return fs.readdirSync(basePath)
    .filter(f => f.endsWith(".blueprint.json"))
    .map(file => {
      const fullPath = path.join(basePath, file)
      const content = JSON.parse(fs.readFileSync(fullPath, "utf-8"))

      if (!Array.isArray(content)) {
        throw new Error(`${file} must export array of blueprints`)
      }

      return {
        file,
        blueprints: content
      }
    })
}



type BlueprintFileType = "model" | "controller"

const TYPE_MAP: Record<BlueprintFileType, { root: string; suffix: string }> = {
  model: {
    root: "app/models",
    suffix: ".model",
  },
  controller: {
    root: "app/controllers",
    suffix: ".controller",
  },
}

export function resolveBlueprintPath(blueprintPath: string, type: BlueprintFileType) {
  const parts     =  blueprintPath.split("/").filter(Boolean)
  const name      =  parts.pop()!
  const folder    =  parts.join("/")
  const config    =  TYPE_MAP[type]

  const basePath  =  path.join(process.cwd(), config.root, folder)
  const filePath  =  path.join(basePath, `${conversion.strSlug(name)}${config.suffix}.ts`)

  if (fs.existsSync(filePath)) {
    const content = fs.readFileSync(filePath, "utf-8")

    if (!content.includes("AUTO-GENERATED BY BLUEPRINT")) {
      logger.info(`Skip overridden file: ${filePath}`)
      return null
    }
  }

  if (!fs.existsSync(basePath)) {
    fs.mkdirSync(basePath, { recursive: true })
  }

  return { name, folder, basePath, filePath }
}
