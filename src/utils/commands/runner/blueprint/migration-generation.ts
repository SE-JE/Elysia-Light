import { conversion, logger } from "@utils";
import fs from "fs";
import path from "path";
import { migrationTimestampFormat } from "../../make/basic-migration";

// ==================================>
// ## Command: Blueprint migration generation
// ==================================>
export async function migrationGeneration(
  model   :  string,
  schema  :  Record<string, string> = {},
  marker  :  string
) : Promise<boolean> {
  const name       =  conversion.strSnake(conversion.strPlural(model.split("/").pop() || ""));
  const basePath   =  path.join(process.cwd(), "src","database", "migrations");
  const timestamp  =  new Date(Date.now());
  const filename   =  `${migrationTimestampFormat(timestamp)}_create_${name}_table.ts`;
  const filePath   =  path.join(basePath, filename);
  const className  =  `create${conversion.strPascal(name)}Table`

  const existingMigrations = fs.readdirSync(basePath).filter((f) => f.includes(`_create_${name}_table`));

  for (const file of existingMigrations) {
    if (fs.existsSync(path.join(basePath, file))) {
      const content = fs.readFileSync(path.join(basePath, file), "utf-8")

      if (!content.includes("AUTO-GENERATED BY BLUEPRINT")) {
        logger.info(`Skip overridden file: *_create_${name}_table.ts`)
        return false
      }
    }

    fs.unlinkSync(path.join(basePath, file));
  }

  const migrationFields: string[] = [];
  for (const [column, definition] of Object.entries(schema)) {
    const typeMatch = /type:(\w+),?(\d+)?/.exec(definition);
    const type = typeMatch?.[1] ?? "string";
    const length = typeMatch?.[2];

    let columnDef = "";
    switch (type) {
      case "bigInteger":
        columnDef = `table.bigInteger("${column}").unsigned()`;
        break;
      case "integer":
        columnDef = `table.integer("${column}")`;
        break;
      case "string":
        columnDef = length
          ? `table.string("${column}", ${length})`
          : `table.string("${column}")`;
        break;
      case "text":
        columnDef = `table.text("${column}")`;
        break;
      default:
        columnDef = `table.${type}("${column}")`;
        break;
    }

    // if (definition.includes("foreignIdFor")) {
    //   const foreign = /foreignIdFor:(\w+),?(\d+)?/.exec(definition);
    //   if (foreign) {
    //     columnDef += `.foreignIdFor(${conversion.strPascal(foreign[1])}, ${
    //       foreign[2] ?? ""
    //     })`;
    //   }
    // }

    if (definition.includes("unique")) {
      columnDef += `.unique()`;
    }
    if (!definition.includes("required")) {
      columnDef += `.nullable()`;
    }
    if (definition.includes("index")) {
      columnDef += `.index()`;
    }

    migrationFields.push(columnDef);
  }

  const migrationSchema = migrationFields.map((f) => `      ${f}`).join("\n");

  const stubPath = path.join(process.cwd(), "src", "utils", "commands", "make", "stubs", "light-migration.stub");
  let stub = fs.readFileSync(stubPath, "utf-8");

  stub  =  stub
    .replace(/{{\s*marker\s*}}/g, marker)
    .replace(/{{\s*className\s*}}/g, className)
    .replace(/{{\s*tableName\s*}}/g, name)
    .replace(/{{\s*schemas\s*}}/g, migrationSchema);

  if (!fs.existsSync(basePath)) {
    fs.mkdirSync(basePath, { recursive: true });
  }

  fs.writeFileSync(filePath, stub, "utf-8");

  return true;
}