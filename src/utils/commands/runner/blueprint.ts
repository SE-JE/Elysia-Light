import fs from "fs";
import path from "path";
import { Command } from "commander";
import { conversion, logger } from "@utils";
import { migrationTimestampFormat } from "../make/basic-migration";



export interface BlueprintSchemaTypes {
  model         :  string;
  schema       ?:  Record<string, string>;
  relations    ?:  Record<string, string>;
  controllers  ?:  Record<string, string> | false;
  seeders      ?:  any[][];
}



const blueprintMarker = `// ============================================
// ## file THIS FILE IS AUTO-GENERATED BY BLUEPRINT
// ?? Blueprint : {{ blueprint }}
// !! If this comment is removed, blueprint engine WILL NOT override this file.
// ============================================


`



// =====================================>
// ## Command: blueprint
// =====================================>
export const blueprintCommand = new Command("blueprint")
  .option("-o, --only <names...>", "Run only specific blueprints")
  .description("Run blueprints")
  .action(async (opts) => {
    await runBlueprints({ only: opts.only })

    logger.info("Success run all blueprints!")
    process.exit(0);
  })


// =======================>
// ## Command: Blueprint engine
// =======================>
export async function runBlueprints(options?: { only?: string[] }) {
  const loaded = loadBlueprintFiles()
  const documentations: any[] = []

  for (const file of loaded) {
    const name = file.file.replace(".blueprint.json", "")

    if (options?.only && !options.only.includes(name)) continue

    const marker = blueprintMarker.replace(/{{ blueprint }}/g, file.file)

    for (const struct of file.blueprints) {
      const schema      = struct.schema ?? {}
      const relations   = struct.relations ?? {}
      const seeders     = struct.seeders ?? []
      const controllers = struct.controllers ?? []

      await modelGeneration(struct.model, schema, relations, marker)

      if (struct.migrations !== false) {
        await migrationGeneration(struct.model, schema, marker)
      }

      if (controllers !== false) {
        if (!!controllers.length) {
          controllers.map(async (item: string) => {
            const [controller, route] = item.split(" ")
            await controllerGeneration(struct.model, schema, relations, controller, route || controller, marker)
          })
          
          if (struct.documentations !== false) {
            documentations.push({ controllers, schema })
          }
        } else {
          await controllerGeneration(struct.model, schema, relations, struct.model, struct.model, marker)
          
          if (struct.documentations !== false) {
            documentations.push({ controllers: {}, schema })
          }
        }
      }

      if (seeders.length) {
        await seederGeneration(struct.model, schema, seeders, marker)
      }
    }
  }

  await documentationGeneration(documentations)
}


// =======================>
// ## Command: Blueprint load json files
// =======================>
function loadBlueprintFiles(dir = "blueprints") {
  const basePath = path.join(process.cwd(), "src", dir)

  if (!fs.existsSync(basePath)) {
    throw new Error("Blueprint folder not found")
  }

  return fs.readdirSync(basePath)
    .filter(f => f.endsWith(".blueprint.json"))
    .map(file => {
      const fullPath = path.join(basePath, file)
      const content = JSON.parse(fs.readFileSync(fullPath, "utf-8"))

      if (!Array.isArray(content)) {
        throw new Error(`${file} must export array of blueprints`)
      }

      return {
        file,
        blueprints: content
      }
    })
}











// ============================>
// ## Command: blueprint model generation
// ============================>
export async function modelGeneration(model: string, schema: Record<string, string> = {}, relations: Record<string, string> = {}, marker: string): Promise<boolean> {
  const resolvePath = resolveBlueprintPath(model, "model");
  if (!resolvePath) { return false };

  const { name, folder, basePath, filePath } = resolvePath;
  const modelName = conversion.strPascal(name);

  let imports: string[] = []
  let importUtils: string[] = ["Field"]

  // ? Fields
  const fields: string[] = []

  for (const [name, def] of Object.entries(schema)) {
    const flags: string[] = []

    if (def.includes("fillable")) flags.push("fillable")
    if (def.includes("searchable")) flags.push("searchable")
    if (def.includes("selectable")) flags.push("selectable")
    if (def.includes("hidden")) flags.push("hidden")

    const decorator = flags.length ? `@Field(${JSON.stringify(flags)})` : ""

    fields.push([
      `    ${decorator}`,
      `    ${name}!: any`
    ].join("\n"))
  }

  // ? Relations
  const relationFields: string[] = []
  
  let importRelations: string[] = [];

  for (const [name, def] of Object.entries(relations)) {
    let type = "BelongsTo"
    let target = def.replace(/\[\]|\[1\]|:/g, "").split(" ")[0]

    if (def.startsWith("[]:")) type = "BelongsToMany"
    else if (def.startsWith("[]")) type = "HasMany"
    else if (def.startsWith("[1]")) type = "HasOne"

    !importUtils.includes(type) && importUtils.push(type)
    importRelations.push(`${target}`)

    const isMany = type === "HasMany" || type === "BelongsToMany"

    relationFields.push([
      `    @${type}(() => ${target})`,
      `    ${name}!: ${isMany ? `${target}[]` : target}`
    ].join("\n"))
  }

  if(importRelations.length) {
    imports.push(`import { ${importRelations.join(", ")} } from '@models'`)
  }

  let stub = fs.readFileSync(path.join(process.cwd(), "src/utils/commands/make/stubs/light-model.stub"), "utf-8")

  const strImportUtils = importUtils?.length ? ", " + importUtils.join(", ") : ""

  stub = stub
    .replace(/{{\s*marker\s*}}/g, marker)
    .replace(/{{\s*name\s*}}/g, modelName)
    .replace(/{{\s*fields\s*}}/g, fields.join("\n\n"))
    .replace(/{{\s*relations\s*}}/g, relationFields.join("\n\n"))
    .replace(/{{\s*attributes\s*}}/g, "")
    .replace(/{{\s*hooks\s*}}/g, "")
    .replace(/{{\s*import\s*}}/g, imports.join("\n"))
    .replace(/{{\s*import_utils\s*}}/g, strImportUtils)

  fs.writeFileSync(filePath, stub, "utf-8")
  return true
}


// ==================================>
// ## Command: Blueprint migration generation
// ==================================>
export async function migrationGeneration(
  model   :  string,
  schema  :  Record<string, string> = {},
  marker  :  string
) : Promise<boolean> {
  const name       =  conversion.strSnake(conversion.strPlural(model.split("/").pop() || ""));
  const basePath   =  path.join(process.cwd(), "src","database", "migrations");
  const timestamp  =  new Date(Date.now());
  const filename   =  `${migrationTimestampFormat(timestamp)}_create_${name}_table.ts`;
  const filePath   =  path.join(basePath, filename);
  const className  =  `create${conversion.strPascal(name)}Table`

  const existingMigrations = fs.readdirSync(basePath).filter((f) => f.includes(`_create_${name}_table`));

  for (const file of existingMigrations) {
    if (fs.existsSync(path.join(basePath, file))) {
      const content = fs.readFileSync(path.join(basePath, file), "utf-8")

      if (!content.includes("AUTO-GENERATED BY BLUEPRINT")) {
        logger.info(`Skip overridden file: *_create_${name}_table.ts`)
        return false
      }
    }

    fs.unlinkSync(path.join(basePath, file));
  }

  const migrationFields: string[] = [];
  for (const [column, definition] of Object.entries(schema)) {
    const typeMatch = /type:(\w+),?(\d+)?/.exec(definition);
    const type = typeMatch?.[1] ?? "string";
    const length = typeMatch?.[2];

    let columnDef = "";
    switch (type) {
      case "bigInteger":
        columnDef = `table.bigInteger("${column}").unsigned()`;
        break;
      case "integer":
        columnDef = `table.integer("${column}")`;
        break;
      case "string":
        columnDef = length
          ? `table.string("${column}", ${length})`
          : `table.string("${column}")`;
        break;
      case "text":
        columnDef = `table.text("${column}")`;
        break;
      default:
        columnDef = `table.${type}("${column}")`;
        break;
    }

    // if (definition.includes("foreignIdFor")) {
    //   const foreign = /foreignIdFor:(\w+),?(\d+)?/.exec(definition);
    //   if (foreign) {
    //     columnDef += `.foreignIdFor(${conversion.strPascal(foreign[1])}, ${
    //       foreign[2] ?? ""
    //     })`;
    //   }
    // }

    if (definition.includes("unique")) {
      columnDef += `.unique()`;
    }
    if (!definition.includes("required")) {
      columnDef += `.nullable()`;
    }
    if (definition.includes("index")) {
      columnDef += `.index()`;
    }

    migrationFields.push(columnDef);
  }

  const migrationSchema = migrationFields.map((f) => `      ${f}`).join("\n");

  const stubPath = path.join(process.cwd(), "src", "utils", "commands", "make", "stubs", "light-migration.stub");
  let stub = fs.readFileSync(stubPath, "utf-8");

  stub  =  stub
    .replace(/{{\s*marker\s*}}/g, marker)
    .replace(/{{\s*className\s*}}/g, className)
    .replace(/{{\s*tableName\s*}}/g, name)
    .replace(/{{\s*schemas\s*}}/g, migrationSchema);

  if (!fs.existsSync(basePath)) {
    fs.mkdirSync(basePath, { recursive: true });
  }

  fs.writeFileSync(filePath, stub, "utf-8");

  return true;
}



// ================================>
// ## Command: Blueprint controller generation
// ================================>
export async function controllerGeneration(
  model        :  string,
  schema       :  Record<string, string>  =  {},
  relations    :  Record<string, string>  =  {},
  controller   :  string                  =  "",
  route        :  string                  =  "",
  marker       :  string
) {
  const resolvePath = resolveBlueprintPath(controller, "controller");
  if (!resolvePath) { return false };

  const { name, folder, basePath, filePath } = resolvePath;

  const modelName = conversion.strPascal(model?.split("/")?.pop() || "");
  const controllerName = conversion.strPascal(controller?.split("/")?.pop() || "") + "Controller";

  const validations = {
    ...generateFieldValidations(model, schema),
    ...generateRelationValidations(relations)
  }

  let stub = fs.readFileSync(path.join(process.cwd(), "src", "utils", "commands", "make", "stubs", "light-controller.stub"), "utf-8");

  stub = stub
    .replace(/{{\s*marker\s*}}/g, marker)
    .replace(/{{\s*name\s*}}/g, controllerName)
    .replace(/{{\s*model\s*}}/g, modelName)
    .replace(/{{\s*validations\s*}}/g, renderValidationObject(validations));

  fs.writeFileSync(filePath, stub, "utf-8");

  apiRouteGeneration(route, controllerName);

  return true;
}



// =============================>
// ## Command: Blueprint route generation
// =============================>
function apiRouteGeneration(routePath: string, controllerName: string) {
  const routesPath = path.join(process.cwd(), "src", "routes", "index.ts")

  let content = fs.readFileSync(routesPath, "utf-8")

  content = ensureControllerImported(content, controllerName)
  content = ensureApiRoute(content, routePath, controllerName)

  fs.writeFileSync(routesPath, content, "utf-8")
}


// =================================>
// ## Command: Blueprint seeder generation
// =================================>
export async function seederGeneration(
  model   :  string,
  schema  :  Record<string, string> = {},
  data    :  any[][] = [],
  marker  :  string
) : Promise<boolean> {
  const modelName  =  conversion.strPascal(model?.split("/")?.pop() || "");
  const basePath   =  path.join(process.cwd(), "src", "database", "seeders");
  const filePath   =  path.join(basePath, `${modelName}.seeder.ts`);
  
  if (fs.existsSync(filePath)) {
    const content = fs.readFileSync(filePath, "utf-8")

    if (!content.includes("AUTO-GENERATED BY BLUEPRINT")) {
      logger.info(`Skip overridden file: ${filePath}`)
      return false
    }
  }

  const schemaKeys = Object.keys(schema);

  const seeders = data.map((row) =>
    `  {${row
      .map((val, idx) => {
        const col = schemaKeys[idx];
        return `"${col}": ${isNaN(val) ? `"${val}"` : val}`;
      })
    .join(", ")}}`).join(",\n    ");

  const stubPath = path.join(process.cwd(), "src", "utils", "commands", "make", "stubs", "light-seeder.stub");
  let stub = fs.readFileSync(stubPath, "utf-8");

  stub = stub
    .replace(/{{\s*marker\s*}}/g, marker)
    .replace(/{{\s*name\s*}}/g, modelName)
    .replace(/{{\s*model\s*}}/g, modelName)
    .replace(/{{\s*seeders\s*}}/g, seeders);

  if (!fs.existsSync(basePath)) {
    fs.mkdirSync(basePath, { recursive: true });
  }

  fs.writeFileSync(filePath, stub, "utf-8");

  return true;
}



// =========================================>
// ## Command: Blueprint documentation generation
// =========================================>
export async function documentationGeneration(
  documentations: Array<Record<string, any>>
): Promise<boolean> {
  const basePath = path.join(process.cwd(), "storage", "documentation");
  const collectionName = process.env.APP_NAME || "API Collection";
  const filePath = path.join(basePath, `${collectionName}(postman).json`);

  if (!fs.existsSync(basePath)) {
    fs.mkdirSync(basePath, { recursive: true });
  }

  if (fs.existsSync(filePath)) {
    fs.unlinkSync(filePath);
  }

  const folders: any[] = [];

  for (const documentation of documentations) {
    const controllers = documentation["controllers"] || {};

    for (const [route] of Object.entries(controllers)) {
      const folderName = route
        .split("-")
        .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
        .join(" ");
      const schema = documentation["schema"] ?? {};

      const crudOperations = [
        {
          name: `Get All ${folderName}`,
          method: "GET",
          path: `${route}`,
          body: {},
        },
        {
          name: `Create ${folderName}`,
          method: "POST",
          path: `${route}`,
          body: extractSchema(schema),
        },
        {
          name: `Update ${folderName}`,
          method: "PUT",
          path: `${route}/{id}`,
          body: extractSchema(schema),
        },
        {
          name: `Delete ${folderName}`,
          method: "DELETE",
          path: `${route}/{id}`,
          body: {},
        },
      ];

      const items = crudOperations.map((endpoint) => ({
        name: endpoint.name,
        request: {
          method: endpoint.method,
          header: [],
          body: {
            mode: "raw",
            raw: JSON.stringify(endpoint.body, null, 2),
          },
          url: {
            raw: `{{base_url}}/${endpoint.path}`,
            host: ["{{base_url}}"],
            path: endpoint.path.split("/"),
          },
        },
      }));

      folders.push({
        name: folderName,
        items,
      });
    }
  }

  const collection = {
    info: {
      name: collectionName,
      schema: "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
    },
    item: folders,
  };

  fs.writeFileSync(filePath, JSON.stringify(collection, null, 2), "utf-8");

  return true;
}






function extractSchema(schema: Record<string, string>) {
  const obj: Record<string, any> = {};
  for (const key of Object.keys(schema)) {
    obj[key] = "";
  }
  return obj;
}



type BlueprintFileType = "model" | "controller"

const TYPE_MAP: Record<BlueprintFileType, { root: string; suffix: string }> = {
  model: {
    root: "src/models",
    suffix: ".model",
  },
  controller: {
    root: "src/controllers",
    suffix: ".controller",
  },
  // migration: {
  //   root: "src/database/migrations",
  //   suffix: "",
  // },
  // seeder: {
  //   root: "src/database/seeders",
  //   suffix: ".seeder",
  // },
}

export function resolveBlueprintPath(blueprintPath: string, type: BlueprintFileType) {
  const parts     =  blueprintPath.split("/").filter(Boolean)
  const name      =  parts.pop()!
  const folder    =  parts.join("/")
  const config    =  TYPE_MAP[type]

  const basePath  =  path.join(process.cwd(), config.root, folder)
  const filePath  =  path.join(basePath, `${name}${config.suffix}.ts`)

  // if (fs.existsSync(filePath)) {
  //   logger.info(`Skip ${type}: ${blueprintPath}`)
  //   return null
  // }

  if (fs.existsSync(filePath)) {
    const content = fs.readFileSync(filePath, "utf-8")

    if (!content.includes("AUTO-GENERATED BY BLUEPRINT")) {
      logger.info(`Skip overridden file: ${filePath}`)
      return null
    }
  }

  if (!fs.existsSync(basePath)) {
    fs.mkdirSync(basePath, { recursive: true })
  }

  return { name, folder, basePath, filePath }
}



function generateFieldValidations(model: string, schema: Record<string, string>) {
  const rules: Record<string, string[]> = {}
  const table = conversion.strSnake(conversion.strPlural(model))

  for (const [field, def] of Object.entries(schema)) {
    const r: string[] = []

    if(def.includes("required")) {
      r.push( "required")
    }

    if (def.includes("type:string")) {
      r.push("string")

      const len = def.match(/type:string,(\d+)/)
      if (len) r.push(`max:${len[1]}`)
    }

    if (def.includes("type:integer") || def.includes("type:bigInteger") || def.includes("type:float")) {
      r.push("numeric")
    }

    const min = def.match(/min:(\d+)/)
    if (min) r.push(`min:${min[1]}`)

    const max = def.match(/max:(\d+)/)
    if (max) r.push(`max:${max[1]}`)

    if (def.includes("unique")) {
      r.push(`unique:${table},${field}`)
    }

    rules[field] = r
  }

  return rules
}

function generateRelationValidations(relations: Record<string, string>) {
  const rules: Record<string, string[]> = {}

  for (const [name, def] of Object.entries(relations)) {
    if (!def.includes("fillable")) continue

    const isMany = def.startsWith("[]") || def.startsWith("[]:")
    const target = def.replace(/[\[\]:]/g, "").split(" ")[0]
    const table  = conversion.strSnake(conversion.strPlural(target))

    if (isMany) {
      rules[name]         =  ["array"]
      rules[`${name}.*`]  =  ["number", `exists:${table},id`]
    } else {
      rules[name]  =  ["number", `exists:${table},id`]
    }
  }

  return rules
}


function renderValidationObject(rules: Record<string, string[]>) {
  return `
${Object.entries(rules).map(([k, v]) => `            "${k}": ${JSON.stringify(v)}`).join(",\n")}
        `
}


function ensureControllerImported(content: string, controllerName: string): string {
  const importBlockRegex = /import\s*\{([\s\S]*?)\}\s*from\s*['"]@controllers['"]/

  if (importBlockRegex.test(content)) {
    return content.replace(importBlockRegex, (match, group) => {
      if (group.includes(controllerName)) return match

      const updated = group.trim() ? `${group.trim()},\n    ${controllerName}` : controllerName

      return `import {\n${updated}\n} from '@controllers'`
    })
  }

  const importLine =
`import {
    ${controllerName}
} from '@controllers'\n\n`

  return importLine + content
}



function ensureApiRoute(content: string, routePath: string, controllerName: string): string {
  const apiLine = `api(route, "${routePath}", ${controllerName});`

  if (content.includes(apiLine)) return content

  const returnIndex = content.lastIndexOf("return route;")
  if (returnIndex === -1) {
    throw new Error("Cannot find `return route;` in routes file")
  }

  return (content.slice(0, returnIndex) + apiLine + "\n    " + content.slice(returnIndex))
}
